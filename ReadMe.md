# 윤성우의 열혈 C++ 코드
기본 개념 / 예제 및 기억할 것들을 메모
---
## 1. C언어 기반의 C++
* 입출력
* 함수 오버로딩   
  * 함수 호출 시 전달되는 인자를 통해 호출하고자 하는 함수의 구분이 가능 (C와 달리 C++은 **함수의 이름 + 매개변수의 선언**)으로 호출할 함수를 찾는다.
* 매개변수의 디폴트 값 (Default Value)
  * 함수의 선언 부분에만 표현
- 인라인 함수
  - 매크로 함수의 대표적인 장/단점은
    - 일반적인 함수에 비해서 실행 속도가 빠르다 <-> 정의하기가 어려우며, 복잡한 함수를 매크로의 형태로 정의하기 어렵다.
    - 또한 매크로를 이용한 함수의 인라인화는 **전처리기**에 의해서 처리
    - 매크로 함수를 이용하면 자료형에 의존적이지 않은 함수를 만들 수 있으나, template을 활용하면 이러한 단점도 상쇄시킬 수 있다.
  - 인라인 함수는 이런 장점을 유지하되 / 단점은 제거한 상태로 사용.
  - inline 키워드를 이용한 함수의 인라인화는 **컴파일러**에 의해서 처리.
  - 또한 컴파일러는 성능에 해가 된다고 판단할 경우 inline 키워드를 무시할 수 있다.
- 이름 공간 (namespace)
  - 서로 다른 프로젝트에서의 같은 이름 충돌을 방지하기 위해서 사용 
  - :: ( 범위 지정 연산자 )를 이용해 접근
    - 또한 ::의 역할은 지역 변수와 전역 변수가 같은 이름을 가질 때 ::을 이용해 전역 변수에 접근을 할 수 있음.

---
## 2. C언어 기반의 C++ (2)
- 참조자
  - 변수에 대해서만 선언이 가능하며, 선언됨과 동시에 누군가를 참조해야만 한다.
  - const 변수에 대한 참조는 const Reference로 받아야 한다.
- Call by value / Call by Reference
  - Call by value 
    - ( 값을 인자로 전달하는 함수의 호출 방식 )
  - Call by Reference
    - ( 주소 값을 전달받아서 함수 외부에 선언된 변수에 접근하는 형태의 함수 호출 방식 )
- 참조자와 const
  - 참조자로 매개변수를 받고 데이터의 변경을 하지 않을 때는 **(const Type& param)** 형태로 받음으로써 데이터의 변경을 하지 않겠다고 선언

- malloc / free <-> new / delete
  - 동적 메모리 할당 방식
  - new / delete 는 객체 대상으로 메모리 할당 후 생성자 호출 / 메모리 해제 전 소멸자 호출을 해주는 것이 malloc / free와 다른 점
  
- C++ 프로젝트에서 C 헤더가 아닌 C++의 헤더를 선언해야 하는 이유.
  - C++ 표준 라이브러리 제공 함수들과 C 표준 라이브러리가 제공하는 함수들이 완전히 일치하는 것은 아님. C++문법을 기반으로 개선된 형태의 라이브러리가 구현되어 있기 때문에 가급적이면 C++ 표준 헤더를 이용하자.

---
## 3. 클래스의 기본
- 특정 자료형에 국한되는 상수들은 클래스 내에 또는 따로 분리된 namespace에 enum으로 정의
- 클래스 내에 함수가 정의되어 있으면 (선언과 정의를 동시에 하는 경우) **함수를 인라인으로 처리하라**는 의미가 있음
- C++에서 class와 struct의 차이는 기본 접근 제한자가 private이냐, public이냐의 차이.
- 인라인으로 선언한 함수는 정의까지 헤더파일에 함께 넣어야 한다.
  - 인라인의 의미를 생각하면 **"컴파일 과정에서 함수의 호출 문이 있는 곳에 함수의 코드가 삽입**되어야 하기 때문이다.
---
## 4. 클래스의 완성
- 정보 은닉 (Information Hiding)
  - 멤버 변수를 private으로 선언, 해당 변수를 접근하는 함수를 별도로 정의 -> 안전한 형태로 멤버 변수의 접근을 유도하는 것
- const 함수
  - 함수 명 const 
  - 1. **이 함수 내에서는 멤버 변수의 값을 변경하지 않겠다**는 의미
  - 2. const가 아닌 함수의 호출을 막는다. 즉 const 함수는 const 함수만을 호출할 수 있다.
    - 코드의 안전성을 높이는 효과가 있음.
- 캡슐화 (Encapsulation)
  - **정보 은닉의 개념 + 관련 있는 함수와 변수를 하나의 클래스 안에 묶는 것 (여러가지 작업을 하나의 틀로 묶어서 처리할 수 있도록 하는)**
  
- 생성자 (Constructor)
  - 매개변수 없는 생성자의 경우
    - class instance(); 와 같은 생성은 **함수의 원형을 선언하는 것으로 취급**되기 때문에 class instance; 와 같이 사용하도록 한다.
  - private 생성자
    - 클래스 내부에서 객체의 생성을 허용하는 목적으로는 생성자를 private하게 설정함.

- 멤버 이니셜라이저 (Member Initializer)
  - 상속 간 base의 생성자를 호출하거나, 생성자 호출 과정에서 객체 멤버의 초기화를 진행시킬 때 사용.
  ```cpp
  class TestClass
  {
    public:
    TestClass() : instances..n(..params) {}
    private:
    Other1 instance1;
    Other2 instance2;
  }

  ```
  - 생성자 함수 내부에서 객체를 초기화 하는 것은 
    - 객체 생성자 호출 (임시 객체 생성) -> = (대입 연산자)를 통한 복사가 이루어지는데
    - **멤버 이니셜라이즈를 사용할 경우 직접 생성자를 호출**하므로 불필요한 작업이 사라진다.
    - 즉, 멤버 이니셜라이즈를 활용하는 경우 **선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성**된다.

- this 포인터
  - this 포인터를 이용해 **Self-Reference (자기 자신의 참조자)**를 반환할 수 있다.

--- 
## 5. 복사 생성자